"""
Shell file generator for shtick
"""

import os
import logging
from pathlib import Path
from typing import Dict, List, Set
from shtick.config import GroupData, Config
from shtick.shells import get_shell_syntax

logger = logging.getLogger("shtick")


class Generator:
    """Generates shell configuration files from parsed data"""

    def __init__(self, output_base_dir: str = None):
        self.output_base_dir = output_base_dir or Config.get_output_dir()
        # Get shells to generate for once
        self._shells_to_generate = None
        self._config_for_shells = None

    @property
    def shells_to_generate(self) -> List[str]:
        """Get list of shells to generate files for"""
        if self._shells_to_generate is None:
            # If we have a config instance stored, use it
            if self._config_for_shells:
                self._shells_to_generate = (
                    self._config_for_shells.get_all_shells_to_generate()
                )
            else:
                # Otherwise create a temporary one just for getting shells
                config = Config()
                self._shells_to_generate = config.get_all_shells_to_generate()
            logger.debug(f"Will generate files for shells: {self._shells_to_generate}")
        return self._shells_to_generate

    def set_config_for_shells(self, config: Config) -> None:
        """Set config instance to use for shell detection"""
        self._config_for_shells = config
        # Clear cached shells to force re-read
        self._shells_to_generate = None

    def ensure_output_dir(self, group_name: str) -> str:
        """Ensure output directory exists and return the path"""
        output_dir = os.path.join(self.output_base_dir, group_name)
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        return output_dir

    def generate_for_group(self, group: GroupData) -> None:
        """Generate all shell files for a single group"""
        logger.info(f"Processing group: {group.name}")

        # Skip if group is empty
        if group.total_items == 0:
            logger.debug(f"Skipping empty group: {group.name}")
            return

        # Prepare all content for the group
        group_content = self._prepare_group_content(group)

        # Generate consolidated files for each shell
        output_dir = self.ensure_output_dir(group.name)
        for shell_name in self.shells_to_generate:
            self._generate_group_file(shell_name, group.name, group_content, output_dir)

    def _prepare_group_content(self, group: GroupData) -> Dict[str, Dict[str, str]]:
        """Prepare all content for a group organized by type"""
        return {
            "alias": group.aliases,
            "env": group.env_vars,
            "function": group.functions,
        }

    def _generate_group_file(
        self,
        shell_name: str,
        group_name: str,
        content: Dict[str, Dict[str, str]],
        output_dir: str,
    ) -> None:
        """Generate a single consolidated file for a shell"""
        shell_syntax = get_shell_syntax(shell_name)

        # Count total items
        total_items = sum(len(items) for items in content.values())
        if total_items == 0:
            return

        logger.debug(
            f"Generating {shell_name} file for group {group_name} ({total_items} items)"
        )

        # Create consolidated file
        filename = f"all.{shell_name}"
        filepath = os.path.join(output_dir, filename)

        with open(filepath, "w") as f:
            # Write header
            f.write(f"# Shtick configuration for {group_name} - {shell_name}\n")
            f.write("# Generated by shtick\n\n")

            # Write aliases
            if content["alias"]:
                f.write(f"# Aliases ({len(content['alias'])})\n")
                for key, value in content["alias"].items():
                    line = shell_syntax.alias_fmt.format(key, value)
                    f.write(line)
                f.write("\n")

            # Write env vars
            if content["env"]:
                f.write(f"# Environment Variables ({len(content['env'])})\n")
                for key, value in content["env"].items():
                    line = shell_syntax.env_fmt.format(key, value)
                    f.write(line)
                f.write("\n")

            # Write functions
            if content["function"]:
                f.write(f"# Functions ({len(content['function'])})\n")
                for key, value in content["function"].items():
                    line = shell_syntax.function_fmt.format(key, value)
                    f.write(line)
                f.write("\n")

    def generate_all(self, config: Config, interactive: bool = True) -> None:
        """Generate shell files for all groups in config"""
        if not config.groups:
            print("No groups found in configuration")
            return

        # Set config for shell detection FIRST
        self.set_config_for_shells(config)

        print(f"Generating shell files for {len(config.groups)} groups...")
        print(f"Target shells: {', '.join(self.shells_to_generate)}")

        for group in config.groups:
            self.generate_for_group(group)

        # Generate the dynamic loader for all shells
        self.generate_loader(config)

        print(f"\nâœ“ All done! Files generated in {self.output_base_dir}")

        if interactive:
            self._print_usage_instructions(config)

    def generate_loader(self, config: Config) -> None:
        """Generate dynamic loader files that source persistent + active groups"""
        logger.info("Generating dynamic loader files...")

        # Set config for shell detection
        self.set_config_for_shells(config)

        active_groups = config.load_active_groups()
        persistent_group = config.get_persistent_group()

        for shell_name in self.shells_to_generate:
            loader_path = os.path.join(
                self.output_base_dir, f"load_active.{shell_name}"
            )

            with open(loader_path, "w") as f:
                f.write(f"# Shtick dynamic loader for {shell_name}\n")
                f.write("# This file is auto-generated - do not edit\n\n")

                # Source persistent group first (always active)
                if persistent_group and persistent_group.total_items > 0:
                    f.write("# Load persistent configuration\n")
                    file_path = f"$HOME/.config/shtick/persistent/all.{shell_name}"
                    f.write(f'[ -f "{file_path}" ] && source "{file_path}"\n\n')

                # Source active groups
                if active_groups:
                    f.write("# Load active groups\n")
                    for group_name in active_groups:
                        group = config.get_group(group_name)
                        if group and group.total_items > 0:
                            f.write(f"# Group: {group_name}\n")
                            file_path = (
                                f"$HOME/.config/shtick/{group_name}/all.{shell_name}"
                            )
                            f.write(f'[ -f "{file_path}" ] && source "{file_path}"\n')
                    f.write("\n")
                else:
                    f.write("# No active groups\n")

    def _print_usage_instructions(self, config: Config) -> None:
        """Print usage instructions for the user"""
        active_groups = config.load_active_groups()
        persistent_group = config.get_persistent_group()
        current_shell = Config.get_current_shell()

        print("\nUsage Instructions:")
        print("=" * 50)

        if current_shell and current_shell in self.shells_to_generate:
            print(f"\nFor {current_shell}, add this to your shell config:")
            loader_path = f"~/.config/shtick/load_active.{current_shell}"

            shell_configs = {
                "bash": "~/.bashrc",
                "zsh": "~/.zshrc",
                "fish": "~/.config/fish/config.fish",
                "ksh": "~/.kshrc",
                "dash": "~/.dashrc",
            }

            config_file = shell_configs.get(current_shell, "your shell config")
            print(f"  # In {config_file}:")
            print(f"  source {loader_path}")
        else:
            # Fallback instructions
            print("\nAdd the appropriate line to your shell config:")
            for shell in self.shells_to_generate[:3]:  # Show top 3
                print(f"  # For {shell}:")
                print(f"  source ~/.config/shtick/load_active.{shell}")

        print("\n" + "=" * 50)

        # Status summary
        if persistent_group:
            print(
                f"\nPersistent items (always active): {persistent_group.total_items} total"
            )

        if active_groups:
            print(f"Active groups: {', '.join(active_groups)}")
        else:
            print(
                "No groups currently active. Use 'shtick activate <group>' to activate groups."
            )

        available_groups = [g.name for g in config.get_regular_groups()]
        if available_groups:
            print(f"Available groups: {', '.join(available_groups)}")

    def get_shell_files_for_group(self, group_name: str) -> List[str]:
        """Get list of generated shell files for a group"""
        group_dir = os.path.join(self.output_base_dir, group_name)
        if not os.path.exists(group_dir):
            return []

        files = []
        for shell in self.shells_to_generate:
            file_path = os.path.join(group_dir, f"all.{shell}")
            if os.path.exists(file_path):
                files.append(file_path)

        return files
