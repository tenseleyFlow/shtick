"""
Shell file generator for shtick
"""

import os
from pathlib import Path
from typing import Dict, List
from shtick.config import GroupData, Config
from shtick.shells import get_supported_shells, get_shell_syntax


class Generator:
    """Generates shell configuration files from parsed data"""

    def __init__(self, output_base_dir: str = None):
        self.output_base_dir = output_base_dir or Config.get_output_dir()

    def ensure_output_dir(self, group_name: str, item_type: str) -> str:
        """Ensure output directory exists and return the path"""
        output_dir = os.path.join(self.output_base_dir, group_name, item_type)
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        return output_dir

    def generate_for_group(self, group: GroupData) -> None:
        """Generate all shell files for a single group"""
        print(f"Processing group: {group.name}")

        # Generate aliases
        if group.aliases:
            print(f"  Generating alias files ({len(group.aliases)} aliases)")
            self._generate_files(group.name, "alias", group.aliases, "aliases")

        # Generate env vars
        if group.env_vars:
            print(f"  Generating env var files ({len(group.env_vars)} variables)")
            self._generate_files(group.name, "env", group.env_vars, "envvars")

        # Generate functions
        if group.functions:
            print(f"  Generating function files ({len(group.functions)} functions)")
            self._generate_files(group.name, "function", group.functions, "functions")

    def _generate_files(
        self, group_name: str, item_type: str, items: Dict[str, str], prefix: str
    ) -> None:
        """Generate shell files for a specific item type"""
        output_dir = self.ensure_output_dir(group_name, item_type)

        # Generate for each supported shell + default
        all_shells = get_supported_shells() + ["default"]

        for shell_name in all_shells:
            shell_syntax = get_shell_syntax(shell_name)
            filename = f"{prefix}.{shell_name}"
            filepath = os.path.join(output_dir, filename)

            with open(filepath, "w") as f:
                # Write header
                f.write(f"# {prefix} for {shell_name}\n")
                f.write("# Generated by shtick\n\n")

                # Write items using appropriate syntax
                for key, value in items.items():
                    if item_type == "alias":
                        line = shell_syntax.alias_fmt.format(key, value)
                    elif item_type == "env":
                        line = shell_syntax.env_fmt.format(key, value)
                    elif item_type == "function":
                        line = shell_syntax.function_fmt.format(key, value)
                    else:
                        continue

                    f.write(line)

    def generate_all(self, config: Config) -> None:
        """Generate shell files for all groups in config"""
        if not config.groups:
            print("No groups found in configuration")
            return

        print(f"Generating shell files for {len(config.groups)} groups...")

        for group in config.groups:
            self.generate_for_group(group)

        # Generate the dynamic loader for all shells
        self.generate_loader(config)

        print(f"All done! Files generated in {self.output_base_dir}")
        self._print_usage_instructions(config)

    def generate_loader(self, config: Config) -> None:
        """Generate dynamic loader files that source persistent + active groups"""
        print("Generating dynamic loader files...")

        active_groups = config.load_active_groups()
        persistent_group = config.get_persistent_group()

        # Generate for each supported shell + default
        all_shells = get_supported_shells() + ["default"]

        for shell_name in all_shells:
            loader_path = os.path.join(
                self.output_base_dir, f"load_active.{shell_name}"
            )

            with open(loader_path, "w") as f:
                f.write(f"# Shtick dynamic loader for {shell_name}\n")
                f.write("# This file is auto-generated - do not edit\n\n")

                # Source persistent group first (always active)
                if persistent_group:
                    f.write("# Load persistent configuration\n")
                    for item_type in ["alias", "env", "function"]:
                        file_path = f"$HOME/.config/shtick/persistent/{item_type}"
                        f.write(f'[ -f "{file_path}/{item_type}s.{shell_name}" ] && ')
                        f.write(f'source "{file_path}/{item_type}s.{shell_name}"\n')
                    f.write("\n")

                # Source active groups
                if active_groups:
                    f.write("# Load active groups\n")
                    for group_name in active_groups:
                        f.write(f"# Group: {group_name}\n")
                        for item_type in ["alias", "env", "function"]:
                            file_path = f"$HOME/.config/shtick/{group_name}/{item_type}"
                            f.write(
                                f'[ -f "{file_path}/{item_type}s.{shell_name}" ] && '
                            )
                            f.write(f'source "{file_path}/{item_type}s.{shell_name}"\n')
                        f.write("\n")
                else:
                    f.write("# No active groups\n")

    def _print_usage_instructions(self, config: Config) -> None:
        """Print usage instructions for the user"""
        active_groups = config.load_active_groups()
        persistent_group = config.get_persistent_group()

        print("\nTo use these configurations, add this line to your shell config:")
        print("  # For bash/zsh (~/.bashrc or ~/.zshrc):")
        print("  source ~/.config/shtick/load_active.bash")
        print("\n  # For fish (~/.config/fish/config.fish):")
        print("  source ~/.config/shtick/load_active.fish")

        if persistent_group:
            total_persistent = (
                len(persistent_group.aliases)
                + len(persistent_group.env_vars)
                + len(persistent_group.functions)
            )
            print(f"\nPersistent items (always active): {total_persistent} total")

        if active_groups:
            print(f"Active groups: {', '.join(active_groups)}")
        else:
            print(
                "No groups currently active. Use 'shtick activate <group>' to activate groups."
            )

        available_groups = [g.name for g in config.get_regular_groups()]
        if available_groups:
            print(f"Available groups: {', '.join(available_groups)}")

    def get_shell_files_for_group(self, group_name: str) -> Dict[str, List[str]]:
        """Get list of generated shell files for a group"""
        files = {"alias": [], "env": [], "function": []}

        for item_type in files.keys():
            type_dir = os.path.join(self.output_base_dir, group_name, item_type)
            if os.path.exists(type_dir):
                files[item_type] = [
                    os.path.join(type_dir, f)
                    for f in os.listdir(type_dir)
                    if os.path.isfile(os.path.join(type_dir, f))
                ]

        return files
